<#@ template language="C#" hostspecific="true" #>
<#@ parameter type="Yagasoft.CrmCodeGenerator.Models.Mapper.Context" name="Context"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Yagasoft.CrmCodeGenerator.Models" #>
<#@ import namespace="Yagasoft.CrmCodeGenerator.Models.Mapping" #>
<#@ import namespace="Yagasoft.CrmCodeGenerator.Models.Settings" #>
<#@ import namespace="Yagasoft.CrmCodeGenerator.Models.Attributes" #>
<#@ assembly name="EnvDTE"#>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Xml.Linq"#>
<#@ import namespace="System"#>
<#@ import namespace="System.CodeDom"#>
<#@ import namespace="System.CodeDom.Compiler"#>
<#@ import namespace="System.Data.Linq"#>
<#@ import namespace="System.Data.Linq.Mapping"#>
<#@ import namespace="System.IO"#>
<#@ import namespace="System.Reflection"#>
<#@ import namespace="System.Text"#>
<#@ import namespace="System.Xml.Linq"#>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#>
<#@ import namespace="System.Text.RegularExpressions"#>
<#@ import namespace="System.Globalization"#>
<# // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Template version 10.1.1 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< #>
<# // >>>>>>>>>> MINIMUM COMPATIBLE VERSION to successfully generate the schema using this template is 10.1.1. <<<<<<<<<< #>
//         Project / File: <#= Context.Namespace #> / <#= Context.FileName #>.cs
// File generated by: CRM Code Generator - Ahmed Elsawalhy (Yagasoft.com)

namespace <#= Context.Namespace #><# if (Context.FileName != "CrmSchema") { #>.<#= Context.FileName #><#}#>

{
<#
	var manager = Manager.Create(Host, GenerationEnvironment);
#>
<#
	Generate(manager);
#>
<#+
	void Generate(Manager manager, MappingEntity entity)
	{
        var oneNRels= entity.RelationshipsOneToMany.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type));
		var nOneRels = entity.RelationshipsManyToOne.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type));
		var nNRels = entity.RelationshipsManyToMany.Where(r => Context.Entities.Select(m => m.LogicalName).Contains(r.Type));
        var entityFilter = Context.CrmEntityProfiles.FirstOrDefault(e => e.LogicalName == entity.LogicalName);
        var crmEntityName = entityFilter?.EntityRename ?? (Context.UseDisplayNames ? entity.FriendlyName : entity.HybridName);
		manager.StartNewFile(Context.FileName + "_" + crmEntityName + ".cs");
#>
<#+	if (Context.SplitFiles) { #>
//         Project / File: <#= Context.Namespace #> / <#= Context.FileName #>.cs
// File generated by: CRM Code Generator - Eric Labashosky, Ahmed el-Sawalhy

namespace <#= Context.Namespace #><#+ if (Context.FileName != "CrmSchema") { #>.<#= Context.FileName #><#+}#>

{
	#region Entities
<#+}#>

	#region <#= crmEntityName #>

	public partial class <#= crmEntityName #>
	{
		public const string DisplayName = <#=ToLiteral(entity.Label)#>;
		public const string SchemaName = "<#=entity.SchemaName#>";
		public const string EntityLogicalName = "<#=entity.LogicalName#>";

<#+ if (Context.PluginMetadataEntities.Contains(entity.LogicalName)) { #>

		#region Enums

<#+ foreach(var enm in entity.Enums) {
        var attribute = entity.Fields.FirstOrDefault(field => field.LogicalName == enm.LogicalName);
        var attributeName = Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter?.AttributeRenames, attribute == null ? "" : attribute.Attribute.LogicalName) ?? enm.FriendlyName) : enm.DisplayName;
 #>
		public enum <#= attributeName #>Enum
		{
<#+ foreach(var item in enm.Items) { #>
			<#= item.Name #> = <#= item.Value #>,
<#+ } #>
		}
	
<#+ } #>

		#endregion

		#region Fields

<#+foreach(var f in entity.Fields.Where(fieldQ => !fieldQ.Attribute.IsEntityReferenceHelper && fieldQ.IsValidForRead)) {#>
		public const string <#= Context.UseDisplayNames ? (FirstNotNullOrEmpty(entityFilter?.AttributeRenames, f.Attribute.LogicalName) ?? f.FriendlyName) : f.DisplayName #> = "<#=f.Attribute.LogicalName#>";
<#+}#>

		#endregion

		#region Relations

		public static class OneToN
		{
<#+ //BEGIN// 1:N Realationships
	foreach(var attribute in oneNRels)	{#>
<#+ if(attribute.SchemaName == "calendar_calendar_rules" || attribute.SchemaName == "service_calendar_rules") { #>
			public const string <#=attribute.SchemaName#> = "calendarrules";
<#+ } else {
			var relationName = FirstNotNullOrEmpty(entityFilter?.OneToNRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
			public const string <#=relationName#> = "<#=attribute.SchemaName#>";
<#+ } #>
<#+ } #>
		}
<#+ //END// 1:N Realationships #>
			
		public static class NToOne
		{
<#+ //BEGIN// N:1 Relationships 
	foreach(var attribute in nOneRels)	{
			var relationName = FirstNotNullOrEmpty(entityFilter?.NToOneRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
			public const string <#= relationName #> = "<#=attribute.SchemaName#>";
<#+ } #>

			public static class Lookups
			{
<#+ //BEGIN// N:1 Relationships lookups
	foreach(var attribute in nOneRels)	{
			var relationName = FirstNotNullOrEmpty(entityFilter?.NToOneRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
			public const string <#=relationName#> = "<#=attribute.LogicalName#>";
<#+ } #>
			}
		}
<#+ //END// N:1 Realationships #>

		public static class NToN
		{

<#+ //BEGIN// N:N Realationships 
	foreach(var attribute in nNRels.GroupBy(element => element.SchemaName).Select(group => group.First()))	{
			var relationName = FirstNotNullOrEmpty(entityFilter?.NToNRenames, attribute.SchemaName) ?? attribute.FriendlyName;
#>
			public const string <#= relationName #> = "<#= attribute.SchemaName #>";
<#+ } #>
		}
<#+ //END// N:N Relationships  #>

		#endregion
<#+ } #>
	}
	
	#endregion

<#+
		manager.EndBlock(); 
	}

	void Generate(Manager manager)
	{
		foreach (var entity in Context.Entities)
		{
			Generate(manager, entity);
		}

		manager.StartFooter();
#>

}

<#+
		manager.EndBlock();

		manager.Process(Context.SplitFiles);
	}
#>
<#+
    // Credit :http://stackoverflow.com/questions/323640/can-i-convert-a-c-sharp-string-value-to-an-escaped-string-literal
    private static string ToLiteral(string input)
    {
        using (var writer = new StringWriter())
        {
            using (var provider = CodeDomProvider.CreateProvider("CSharp"))
            {
                provider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);
                return writer.ToString();
            }
        }
    }

    private static TValue FirstNotNullOrDefault<TKey, TValue>(IDictionary<TKey, TValue> dictionary, params TKey[] keys)
    {
		if (dictionary == null) return default;
		return Enumerable.FirstOrDefault<TValue>(Enumerable.Select<TKey, TValue>(Enumerable.Where<TKey>((IEnumerable<TKey>) keys, new Func<TKey, bool>(dictionary.ContainsKey)), (Func<TKey, TValue>) (key => dictionary[key])));
    }

    private static string FirstNotNullOrEmpty<TKey>(IDictionary<TKey, string> dictionary, params TKey[] keys)
    {
		if (dictionary == null) return default;
        return Enumerable.FirstOrDefault<string>(Enumerable.Select<TKey, string>(Enumerable.Where<TKey>((IEnumerable<TKey>)keys, (Func<TKey, bool>)(key =>
        {
            if (dictionary.ContainsKey(key))
                return !string.IsNullOrEmpty(dictionary[key]);
            return false;
        })), (Func<TKey, string>)(key => dictionary[key])));
    }

	// Credit: https://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
	// Manager class records the various blocks so it can split them up
	class Manager {
		private class Block {
			public String Name;
			public int Start, Length;
		}

		private Block currentBlock;
		private List<Block> files = new List<Block>();
		private Block footer = new Block();
		private Block header = new Block();
		private ITextTemplatingEngineHost host;
		private StringBuilder template;
		protected List<String> generatedFileNames = new List<String>();

		public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
			return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
		}

		public void StartNewFile(String name) {
			if (name == null)
				throw new ArgumentNullException("name");
			CurrentBlock = new Block { Name = name };
		}

		public void StartFooter() {
			CurrentBlock = footer;
		}

		public void StartHeader() {
			CurrentBlock = header;
		}

		public void EndBlock() {
			if (CurrentBlock == null)
				return;
			CurrentBlock.Length = template.Length - CurrentBlock.Start;
			if (CurrentBlock != header && CurrentBlock != footer)
				files.Add(CurrentBlock);
			currentBlock = null;
		}

		public virtual void Process(bool split) {
			if (split) {
				EndBlock();
				String headerText = template.ToString(header.Start, header.Length);
				String footerText = template.ToString(footer.Start, footer.Length);
				String outputPath = Path.GetDirectoryName(host.TemplateFile);
				files.Reverse();
				foreach(Block block in files) {
					String fileName = Path.Combine(outputPath, block.Name);
					String content = headerText + template.ToString(block.Start, block.Length) + footerText;
					generatedFileNames.Add(fileName);
					CreateFile(fileName, content);
					template.Remove(block.Start, block.Length);
				}
			}
		}

		protected virtual void CreateFile(String fileName, String content) {
			if (IsFileContentDifferent(fileName, content))
				File.WriteAllText(fileName, content);
		}

		public virtual String GetCustomToolNamespace(String fileName) {
			return null;
		}

		public virtual String DefaultProjectNamespace {
			get { return null; }
		}

		protected bool IsFileContentDifferent(String fileName, String newContent) {
			return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
		}

		private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
			this.host = host;
			this.template = template;
		}

		private Block CurrentBlock {
			get { return currentBlock; }
			set {
				if (CurrentBlock != null)
					EndBlock();
				if (value != null)
					value.Start = template.Length;
				currentBlock = value;
			}
		}

		private class VSManager: Manager {
			private EnvDTE.ProjectItem templateProjectItem;
			private EnvDTE.DTE dte;
			private Action<String> checkOutAction;
			private Action<IEnumerable<String>> projectSyncAction;

			public override String DefaultProjectNamespace {
				get {
					return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
				}
			}

			public override String GetCustomToolNamespace(string fileName) {
				return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
			}

			public override void Process(bool split) {
				if (templateProjectItem.ProjectItems == null)
					return;
				base.Process(split);
				projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
			}

			protected override void CreateFile(String fileName, String content) {
				if (IsFileContentDifferent(fileName, content)) {
					CheckoutFileIfRequired(fileName);
					File.WriteAllText(fileName, content);
				}
			}

			internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
				: base(host, template) {
				var hostServiceProvider = (IServiceProvider) host;
				if (hostServiceProvider == null)
					throw new ArgumentNullException("Could not obtain IServiceProvider");
				dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
				if (dte == null)
					throw new ArgumentNullException("Could not obtain DTE from host");
				templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
				checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
				projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
			}

			private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
				var keepFileNameSet = new HashSet<String>(keepFileNames);
				var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
				var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
				foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
					projectFiles.Add(projectItem.get_FileNames(0), projectItem);

				// Remove unused items from the project
				foreach(var pair in projectFiles)
					if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
						pair.Value.Delete();

				// Add missing files to the project
				foreach(String fileName in keepFileNameSet)
					if (!projectFiles.ContainsKey(fileName))
						templateProjectItem.ProjectItems.AddFromFile(fileName);
			}

			private void CheckoutFileIfRequired(String fileName) {
				var sc = dte.SourceControl;
				if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
					checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
			}
		}
	}
#>
